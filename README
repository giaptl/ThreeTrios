OVERVIEW:
This project is a Java-based application designed to read and parse configuration files for setting
up the initial state of a grid-based card game. It ensures data integrity by validating the format
and uniqueness of the configuration data. The application reads a grid configuration file to
initialize a grid with holes and card cells, and a card database file to initialize a list of cards
with unique names and predefined attack values. The game model manages the game state, including
player hands, grid state, and game logic, and implements battle logic to handle card interactions
based on their attack values and positions on the grid.

QUICK START:

public class ThreeTrios {

  public static void main(String[] args) {
    try {
      String gridConfigPath = "configFiles" + File.separator + "board.config";
      String cardDataPath = "configFiles" + File.separator + "cards.config";

      Grid grid = ConfigurationReader.readGridConfig(gridConfigPath);
      System.out.println("Grid loaded successfully with " + grid.getRows() + " rows and " +
              grid.getColumns() + " columns.");

      List<Card> cards = ConfigurationReader.readCardData(cardDataPath);
      System.out.println("Card data loaded successfully with " + cards.size() + " cards.");

    } catch (IOException e) {
      System.err.println("Error reading configuration files: " + e.getMessage());
    } catch (IllegalArgumentException e) {
      System.err.println("Invalid configuration: " + e.getMessage());
    }
  }
}

- This is the entry point for the application. It demonstrates how to use the ConfigurationReader
to read and parse through the grid and card files.


KEY COMPONENTS:
ConfigurationReader: Reads and parses grid and card configuration files.
readGridConfig: Initializes a grid with holes and card cells.
readCardData: Initializes a list of cards with unique names and predefined attack values.
ThreeTriosModel: Manages the game state, including player hands, grid state, and game logic.
ThreeTrios: Entry point for the application, demonstrating how to use the ConfigurationReader.

KEY SUBCOMPONENTS:
Grid: Represents the game grid with rows and columns.
Card: Represents a card with a name and attack values for different directions.
Player: Represents a player in the game with a hand of cards.

SOURCE ORG:
src/: Contains the main source code.
model/: Contains the game model classes (Grid, Card, Player, etc.).
configuration/: Contains the ConfigurationReader class.
configFiles/: Contains the example configuration files to test
test/: Contains test cases for the application.

INVARIANT:
The currentPlayer must always be either pRed or pBlue.
This is enforced through the constructor and methods of the GameModel class. The constructor
initializes the currentPlayer to either pRed, so the invariant is ensured by the constructor. Methods
that modify currentPlayer ensure it is set to either pRed or pBlue. For example, the playCard method
switches the current player after a card is played to either Red or Blue, which proves that the
methods of this class also maintain the invariant.

----------------------------------------------------------------------------------------------------
Changes for part 2:

Adding missing functionality to the ThreeTriosModel class: We added a method copyOfGrid() to the
Grid class so that a copy of the grid can be retrieved from the model by calling this method on
the grid object. This functionality was originally missing because we previously did not account
for making sure that getGrid() in the model returned an immutable copy of the grid. We also added a
method called getNumCardsAbleToFlip() which returns the number of cards that can be flipped given a
card and a position on the grid. We were originally missing this functionality because we did not
account for the AI player when we were setting up our model. We also updated our ThreeTriosModel
interface to include this new method. We also added a method called getPlayerScore() that takes in
a player and returns that player's score. We originally had a method called getWinner() which was
basically the same code as getPlayerScore() but returned the player object instead of the score. So,
to be more specific according to the requirements of the functionality, we added the method which
utilizes the same helper method as getWinner().

Initially we had our observer methods in the ThreeTriosModel interface, but those were abstracted to
our ReadOnlyThreeTriosModel. With the methods that changed and what not being stated in the paragraph
above.

We also added a barebones controller, where it has the methods to play cards to the board and we can
see how the card owner changes based on the chain rule that the game requires. This implementation
of the controller is not complete and still requires us to implement a lot of the intricacies of the
game that we will complete in our next assignment.
 - This controller is also the part of our app which manages which card is currently being selected.
    This is important because the user needs to know which card is currently selected so that they
    can play it to the board. This happens by calling updateCardSelection() in the controller. That
    method is in the view and is called when a card is clicked on.

We created a MockModel which implements a very stub implementation of the main model so that we can
test out the strategies and also write a couple tests for the controller. Which we will more
comprehensively test in our next assignment.

Our view package contains all the code and info. for the GUI that is being displayed. This is how
the user will be able to see our game and eventually play it at its full functionality. The main
code for it is in GameView, while the CardPanel class represents each card on the board.

We also created a new test package within the test folder called strategy to hold the tests for our
strategy interface. We also did the same with the controller to hold the tests that we are using
for the controller.

The screenshots needed for the assignment are located in a folder called "ViewScreenShots"